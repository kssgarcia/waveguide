import numpy as np

def gen_p1grid(nref):
    """
    Generate a triangular grid by uniform refinement.
    
    Parameters:
    nref (int): Number of refinement levels (>=1)
    
    Returns:
    tuple: (ne, np, p, conn, gbc)
        ne: total number of elements
        np: total number of nodes
        p: the x- and y-coordinates of all nodes (np x 2 array)
        conn: connectivity matrix (ne x 3 array)
        gbc: boundary condition indicator for all nodes (1 for Dirichlet, 0 for inner)
    """
    # Define an initial coarse mesh
    ne = 4
    
    # Initialize arrays for coordinates and boundary flags
    x = np.zeros((4, 6))  # 4 elements, up to 6 nodes per element during refinement
    y = np.zeros((4, 6))
    efl = np.zeros((4, 6), dtype=int)
    
    # First element
    x[0, 0], y[0, 0], efl[0, 0] = 0.5, 0.5, 0   # 0 for inner node
    x[0, 1], y[0, 1], efl[0, 1] = 1.0, 0.0, 1   # 1 for Dirichlet node
    x[0, 2], y[0, 2], efl[0, 2] = 1.0, 1.0, 1
    
    # Second element
    x[1, 0], y[1, 0], efl[1, 0] = 0.5, 0.5, 0
    x[1, 1], y[1, 1], efl[1, 1] = 1.0, 1.0, 1
    x[1, 2], y[1, 2], efl[1, 2] = 0.0, 1.0, 1
    
    # Third element
    x[2, 0], y[2, 0], efl[2, 0] = 0.5, 0.5, 0
    x[2, 1], y[2, 1], efl[2, 1] = 0.0, 1.0, 1
    x[2, 2], y[2, 2], efl[2, 2] = 0.0, 0.0, 1
    
    # Fourth element
    x[3, 0], y[3, 0], efl[3, 0] = 0.5, 0.5, 0
    x[3, 1], y[3, 1], efl[3, 1] = 0.0, 0.0, 1
    x[3, 2], y[3, 2], efl[3, 2] = 1.0, 0.0, 1
    
    # Generate finer mesh based on the given coarse mesh
    for i in range(nref):
        nm = 0  # count the elements generated by each refinement
        max_new_elements = 4 * ne
        xn = np.zeros((max_new_elements, 3))
        yn = np.zeros((max_new_elements, 3))
        efln = np.zeros((max_new_elements, 3), dtype=int)
        
        for j in range(ne):
            # Mid-edge nodes of each triangle become new nodes
            x[j, 3] = 0.5 * (x[j, 0] + x[j, 1])
            y[j, 3] = 0.5 * (y[j, 0] + y[j, 1])
            x[j, 4] = 0.5 * (x[j, 1] + x[j, 2])
            y[j, 4] = 0.5 * (y[j, 1] + y[j, 2])
            x[j, 5] = 0.5 * (x[j, 2] + x[j, 0])
            y[j, 5] = 0.5 * (y[j, 2] + y[j, 0])
            
            # Generate mid-node BC indicator from its parent
            efl[j, 3] = 1 if (efl[j, 0] == 1 and efl[j, 1] == 1) else 0
            efl[j, 4] = 1 if (efl[j, 1] == 1 and efl[j, 2] == 1) else 0
            efl[j, 5] = 1 if (efl[j, 2] == 1 and efl[j, 0] == 1) else 0
            
            # Generate four sub-elements
            
            # 1st sub-element
            xn[nm, 0], yn[nm, 0], efln[nm, 0] = x[j, 0], y[j, 0], efl[j, 0]
            xn[nm, 1], yn[nm, 1], efln[nm, 1] = x[j, 3], y[j, 3], efl[j, 3]
            xn[nm, 2], yn[nm, 2], efln[nm, 2] = x[j, 5], y[j, 5], efl[j, 5]
            nm += 1
            
            # 2nd sub-element
            xn[nm, 0], yn[nm, 0], efln[nm, 0] = x[j, 3], y[j, 3], efl[j, 3]
            xn[nm, 1], yn[nm, 1], efln[nm, 1] = x[j, 1], y[j, 1], efl[j, 1]
            xn[nm, 2], yn[nm, 2], efln[nm, 2] = x[j, 4], y[j, 4], efl[j, 4]
            nm += 1
            
            # 3rd sub-element
            xn[nm, 0], yn[nm, 0], efln[nm, 0] = x[j, 5], y[j, 5], efl[j, 5]
            xn[nm, 1], yn[nm, 1], efln[nm, 1] = x[j, 4], y[j, 4], efl[j, 4]
            xn[nm, 2], yn[nm, 2], efln[nm, 2] = x[j, 2], y[j, 2], efl[j, 2]
            nm += 1
            
            # 4th sub-element
            xn[nm, 0], yn[nm, 0], efln[nm, 0] = x[j, 3], y[j, 3], efl[j, 3]
            xn[nm, 1], yn[nm, 1], efln[nm, 1] = x[j, 4], y[j, 4], efl[j, 4]
            xn[nm, 2], yn[nm, 2], efln[nm, 2] = x[j, 5], y[j, 5], efl[j, 5]
            nm += 1
        
        ne = 4 * ne  # increase the number of elements by a factor of four
        x = np.zeros((ne, 6))
        y = np.zeros((ne, 6))
        efl = np.zeros((ne, 6), dtype=int)
        
        for k in range(ne):  # relabel the new points
            for l in range(3):
                x[k, l] = xn[k, l]
                y[k, l] = yn[k, l]
                efl[k, l] = efln[k, l]
    
    # Get rid of redundant mid-edge nodes:
    # fix the first element, then loop the rest elements
    p = np.zeros((3, 2))
    # gbc = np.zeros((3, 2), dtype=int)
    gbc = np.zeros((3, 2))
    conn = np.zeros((ne, 3), dtype=int)
    
    p[0, 0], p[0, 1], gbc[0, 0] = x[0, 0], y[0, 0], efl[0, 0]
    p[1, 0], p[1, 1], gbc[1, 0] = x[0, 1], y[0, 1], efl[0, 1]
    p[2, 0], p[2, 1], gbc[2, 0] = x[0, 2], y[0, 2], efl[0, 2]
    conn[0, 0], conn[0, 1], conn[0, 2] = 0, 1, 2  # Python uses 0-based indexing
    
    nn = 3  # we already have 3 nodes from 1st element!
    
    # Loop over rest elements: Id=0 means a new node
    eps = 1.0e-8
    
    for i in range(1, ne):  # loop over elements
        for j in range(3):  # loop over element nodes
            Id = False
            for k in range(nn):
                if (abs(x[i, j] - p[k, 0]) < eps and abs(y[i, j] - p[k, 1]) < eps):
                    Id = True  # indicate this node has already been used
                    conn[i, j] = k  # jth node of element i = kth global node
                    break
            
            if not Id:  # record the new node
                p = np.vstack([p, [x[i, j], y[i, j]]])
                gbc = np.vstack([gbc, [efl[i, j], 0]])
                conn[i, j] = nn
                nn += 1
    
    # Convert to 1-based indexing for compatibility with MATLAB version
    # conn += 1
    
    return ne, nn, p, conn, gbc
